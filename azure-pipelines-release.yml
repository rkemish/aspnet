name: 'Release Pipeline'

# ──────────────────────────────────────────────
# Triggered by successful CI pipeline on main
# ──────────────────────────────────────────────
trigger: none

resources:
  pipelines:
    - pipeline: ci
      source: 'AzureDevops CI'
      trigger:
        branches:
          include:
            - main

variables:
  - group: deployment-details

stages:

  # ──────────────────────────────────────────────
  # Stage 1: Infrastructure Scan (PSRule for Azure)
  # ──────────────────────────────────────────────
  - stage: InfrastructureScan
    displayName: Infrastructure Security Scan

    jobs:
      - job: PSRuleScan
        displayName: PSRule for Azure - Bicep Validation
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self

          - task: PowerShell@2
            displayName: 'Install PSRule for Azure'
            inputs:
              targetType: 'inline'
              script: |
                Install-Module -Name PSRule.Rules.Azure -Force -Scope CurrentUser
                Install-Module -Name PSRule -Force -Scope CurrentUser
              pwsh: true

          - task: PowerShell@2
            displayName: 'Run PSRule Analysis on Bicep'
            continueOnError: true
            inputs:
              targetType: 'inline'
              script: |
                $results = Invoke-PSRule -InputPath 'infra/' `
                  -Module PSRule.Rules.Azure `
                  -As Summary `
                  -OutputFormat Markdown `
                  -OutputPath '$(Build.ArtifactStagingDirectory)/psrule-report.md'

                # Also output to console for pipeline logs
                Invoke-PSRule -InputPath 'infra/' `
                  -Module PSRule.Rules.Azure `
                  -As Detail

                Write-Host "PSRule analysis complete. See artifact for full report."
              pwsh: true

          - task: PublishPipelineArtifact@1
            displayName: 'Publish PSRule Report'
            condition: always()
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifact: 'infrastructure-scan'

  # ──────────────────────────────────────────────
  # Stage 2: Provision Infrastructure (Bicep)
  # ──────────────────────────────────────────────
  - stage: Infrastructure
    displayName: Provision Infrastructure
    dependsOn: InfrastructureScan

    jobs:
      - job: DeployBicep
        displayName: Deploy Bicep Templates
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Deploy Bicep'
            inputs:
              azureSubscription: 'Azure'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az group create \
                  --name "$(resourceGroupName)" \
                  --location "$(location)"

                az deployment group create \
                  --resource-group "$(resourceGroupName)" \
                  --template-file infra/main.bicep \
                  --parameters infra/main.bicepparam \
                  --parameters \
                    appName="$(webAppName)"

          # Role assignments require 'User Access Administrator' or 'Owner' on the
          # resource group. continueOnError lets the pipeline proceed if the SP
          # only has Contributor — assign roles manually in that case.
          - task: AzureCLI@2
            displayName: 'Assign App Configuration Reader roles'
            continueOnError: true
            inputs:
              azureSubscription: 'Azure'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                APP_CONFIG_ID=$(az appconfig show \
                  --name "$(webAppName)-config" \
                  --resource-group "$(resourceGroupName)" \
                  --query id -o tsv)

                WEBAPP_PRINCIPAL=$(az webapp identity show \
                  --name "$(webAppName)" \
                  --resource-group "$(resourceGroupName)" \
                  --query principalId -o tsv)

                STAGING_PRINCIPAL=$(az webapp identity show \
                  --name "$(webAppName)" \
                  --resource-group "$(resourceGroupName)" \
                  --slot staging \
                  --query principalId -o tsv)

                echo "Assigning App Configuration Data Reader to web app..."
                az role assignment create \
                  --assignee-object-id "$WEBAPP_PRINCIPAL" \
                  --assignee-principal-type ServicePrincipal \
                  --role "App Configuration Data Reader" \
                  --scope "$APP_CONFIG_ID"

                echo "Assigning App Configuration Data Reader to staging slot..."
                az role assignment create \
                  --assignee-object-id "$STAGING_PRINCIPAL" \
                  --assignee-principal-type ServicePrincipal \
                  --role "App Configuration Data Reader" \
                  --scope "$APP_CONFIG_ID"

  # ──────────────────────────────────────────────
  # Stage 3: Deploy to Staging Slot (Blue)
  # ──────────────────────────────────────────────
  - stage: DeployStaging
    displayName: Deploy to Staging Slot
    dependsOn: Infrastructure

    jobs:
      - deployment: DeployToStaging
        displayName: Deploy to Staging
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - download: ci
                  artifact: drop

                - task: AzureWebApp@1
                  displayName: 'Deploy to Staging Slot'
                  inputs:
                    azureSubscription: 'Azure'
                    appType: 'webAppLinux'
                    appName: '$(webAppName)'
                    deployToSlotOrASE: true
                    resourceGroupName: '$(resourceGroupName)'
                    slotName: 'staging'
                    package: '$(Pipeline.Workspace)/ci/drop/**/*.zip'

                - task: AzureCLI@2
                  displayName: 'Verify Staging Health'
                  inputs:
                    azureSubscription: 'Azure'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      STAGING_URL="https://$(webAppName)-staging.azurewebsites.net"
                      echo "Waiting for staging slot to respond..."

                      for i in $(seq 1 30); do
                        STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL" || true)
                        if [ "$STATUS" = "200" ]; then
                          echo "Staging slot is healthy (HTTP 200)"
                          exit 0
                        fi
                        echo "Attempt $i: HTTP $STATUS - retrying in 10s..."
                        sleep 10
                      done

                      echo "##vso[task.logissue type=error]Staging slot health check failed"
                      exit 1

      - job: StagingSecurityScan
        displayName: Staging Security Scans
        dependsOn: DeployToStaging
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - checkout: self

          - script: |
              chmod +x scripts/zap-baseline.sh
              scripts/zap-baseline.sh "https://$(webAppName)-staging.azurewebsites.net" "$(Build.ArtifactStagingDirectory)"
            displayName: 'OWASP ZAP Baseline Scan'
            continueOnError: true

          - script: |
              chmod +x scripts/ssl-scan.sh
              scripts/ssl-scan.sh "$(webAppName)-staging.azurewebsites.net" "$(Build.ArtifactStagingDirectory)"
            displayName: 'SSL/TLS Scan (testssl.sh)'
            continueOnError: true

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Security Scan Reports'
            condition: always()
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)'
              artifact: 'staging-security-scans'

  # ──────────────────────────────────────────────
  # Stage 4: Manual Approval and Swap (Green)
  # ──────────────────────────────────────────────
  - stage: SwapToProduction
    displayName: Swap to Production
    dependsOn: DeployStaging

    jobs:
      - deployment: SwapSlots
        displayName: Swap Staging to Production
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureAppServiceManage@0
                  displayName: 'Swap Staging → Production'
                  inputs:
                    azureSubscription: 'Azure'
                    action: 'Swap Slots'
                    webAppName: '$(webAppName)'
                    resourceGroupName: '$(resourceGroupName)'
                    sourceSlot: 'staging'

                - task: AzureCLI@2
                  displayName: 'Verify Production Health'
                  inputs:
                    azureSubscription: 'Azure'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      PROD_URL="https://$(webAppName).azurewebsites.net"
                      echo "Verifying production after swap..."

                      for i in $(seq 1 10); do
                        STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$PROD_URL" || true)
                        if [ "$STATUS" = "200" ]; then
                          echo "Production is healthy (HTTP 200)"
                          exit 0
                        fi
                        echo "Attempt $i: HTTP $STATUS - retrying in 10s..."
                        sleep 10
                      done

                      echo "##vso[task.logissue type=warning]Production health check did not return 200"
                      exit 1

      - job: ProductionValidation
        displayName: Production Security Validation
        dependsOn: SwapSlots
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: AzureCLI@2
            displayName: 'Validate Production Security Configuration'
            continueOnError: true
            inputs:
              azureSubscription: 'Azure'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "========================================="
                echo "Production Security Validation"
                echo "========================================="

                FAILED=0

                # Check HTTPS Only
                HTTPS_ONLY=$(az webapp show \
                  --name "$(webAppName)" \
                  --resource-group "$(resourceGroupName)" \
                  --query "httpsOnly" -o tsv)
                if [ "$HTTPS_ONLY" = "true" ]; then
                  echo "✅ HTTPS Only: enabled"
                else
                  echo "❌ HTTPS Only: DISABLED"
                  FAILED=1
                fi

                # Check Managed Identity
                IDENTITY=$(az webapp identity show \
                  --name "$(webAppName)" \
                  --resource-group "$(resourceGroupName)" \
                  --query "type" -o tsv 2>/dev/null || echo "None")
                if [ "$IDENTITY" != "None" ] && [ -n "$IDENTITY" ]; then
                  echo "✅ Managed Identity: $IDENTITY"
                else
                  echo "❌ Managed Identity: not configured"
                  FAILED=1
                fi

                # Check Minimum TLS Version
                MIN_TLS=$(az webapp show \
                  --name "$(webAppName)" \
                  --resource-group "$(resourceGroupName)" \
                  --query "siteConfig.minTlsVersion" -o tsv)
                if [ "$MIN_TLS" = "1.2" ] || [ "$MIN_TLS" = "1.3" ]; then
                  echo "✅ Minimum TLS Version: $MIN_TLS"
                else
                  echo "⚠️  Minimum TLS Version: $MIN_TLS (recommend 1.2+)"
                  FAILED=1
                fi

                # Check FTPS State
                FTPS_STATE=$(az webapp show \
                  --name "$(webAppName)" \
                  --resource-group "$(resourceGroupName)" \
                  --query "siteConfig.ftpsState" -o tsv)
                if [ "$FTPS_STATE" = "Disabled" ] || [ "$FTPS_STATE" = "FtpsOnly" ]; then
                  echo "✅ FTPS State: $FTPS_STATE"
                else
                  echo "⚠️  FTPS State: $FTPS_STATE (recommend Disabled or FtpsOnly)"
                fi

                echo "========================================="
                if [ "$FAILED" -eq 1 ]; then
                  echo "##vso[task.logissue type=warning]Some production security checks did not pass"
                else
                  echo "All production security checks passed"
                fi
